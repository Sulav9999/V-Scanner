import socket
import re
import requests
import json
import os
from datetime import datetime
from tabulate import tabulate

class VulnerabilityScanner:
    def __init__(self, api_key=None):
        self.api_key = api_key
        self.headers = {"apiKey": api_key} if api_key else {}
        self.nvd_api_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"

    def scan(self, target_ip, target_port):
        """Scan a target IP and port for vulnerabilities."""
        try:
            # Step 1: Check if port is open
            port_info = self._scan_port(target_ip, target_port)
            if not port_info:
                print(f"❌ Port {target_port} is closed or unreachable")
                return None

            # Step 2: Identify service
            port, protocol, banner = port_info
            service_info = self._identify_service(port, protocol, banner)
            print(f"\n🔍 Scanning {target_ip}:{port} ({service_info['service']} {service_info['version']})...")

            # Step 3: Fetch CVEs
            cves = self._get_cve_details(service_info)

            # Step 4: Process results
            if cves:
                self._display_results(cves)
                self._save_report(target_ip, service_info, cves)
                return cves
            else:
                print("✅ No known vulnerabilities found.")
                return None

        except Exception as e:
            print(f"⚠️ Error during scan: {str(e)}")
            return None

    def _scan_port(self, ip, port, protocol='tcp'):
        """Check if a port is open and fetch banner."""
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.settimeout(2)
                if sock.connect_ex((ip, port)) == 0:
                    banner = self._get_banner(sock, port)
                    return (port, protocol.upper(), banner)
            return None
        except:
            return None

    def _get_banner(self, sock, port):
        """Fetch service banner."""
        try:
            if port == 135:  # MSRPC
                return "MSRPC Service"
            elif port == 445:  # SMB
                sock.send(b"\x00\x00\x00\x85\xff\x53\x4d\x42")
                return "SMB " + sock.recv(1024).hex()[:20]
            elif port == 80:  # HTTP
                sock.send(b"GET / HTTP/1.0\r\n\r\n")
                return sock.recv(1024).decode(errors='ignore').split('\r\n')[0]
            else:
                sock.send(b"\r\n")
                return sock.recv(1024).decode(errors='ignore').strip() or "Unknown"
        except:
            return "No banner"

    def _identify_service(self, port, protocol, banner):
        """Identify service running on a port."""
        service_map = {
            135: ('MSRPC', 'microsoft'),
            139: ('NetBIOS', 'microsoft'),
            445: ('SMB', 'microsoft'),
            80: ('HTTP', 'httpd'),
            443: ('HTTPS', 'httpd'),
            22: ('SSH', 'openssh'),
            21: ('FTP', 'ftp')
        }
        service, vendor = service_map.get(port, (f"Port {port}", "unknown"))
        
        version = "unknown"
        if "microsoft" in vendor.lower():
            version = self._parse_windows_version(banner)
        elif banner and banner != "No banner":
            version = self._parse_version(banner)
            
        return {
            'port': port,
            'protocol': protocol,
            'service': service,
            'vendor': vendor,
            'version': version,
            'banner': banner
        }

    def _parse_version(self, banner):
        """Extract version from banner."""
        version_patterns = [
            r"(?:Apache|HTTPD)/([\d.]+)",
            r"(?:nginx)/([\d.]+)",
            r"(?:SSH-[\d.]+-openssh_)([\d.]+)",
            r"(?:FTP server \(Version ([\d.]+)\))"
        ]
        for pattern in version_patterns:
            match = re.search(pattern, banner)
            if match:
                return match.group(1)
        return "unknown"

    def _parse_windows_version(self, banner):
        """Special handling for Windows services."""
        if "SMB" in banner:
            return "Windows SMB"
        elif "MSRPC" in banner:
            return "Windows RPC"
        return "Windows"

    def _get_cve_details(self, service_info):
        """Fetch CVEs from NVD API."""
        try:
            params = {
                "keywordSearch": f"{service_info['vendor']} {service_info['service']}",
                "resultsPerPage": 20
            }
            response = requests.get(
                self.nvd_api_url,
                headers=self.headers,
                params=params,
                timeout=10
            )
            return response.json().get("vulnerabilities", [])
        except Exception as e:
            print(f"⚠️ Failed to fetch CVEs: {str(e)}")
            return []

    def _display_results(self, cves):
        """Display vulnerabilities in a table."""
        table_data = []
        for cve in cves:
            cve_id = cve["cve"]["id"]
            description = next(
                (d["value"] for d in cve["cve"].get("descriptions", [])
                if d["lang"] == "en"), "No description"
            )
            
            # Get CVSS metrics
            metrics = cve["cve"].get("metrics", {})
            cvss_data = {}
            
            for ver in ["V31", "V30", "V2"]:
                key = f"cvssMetric{ver}"
                if key in metrics:
                    cvss_data = metrics[key][0]["cvssData"]
                    break
            
            score = str(cvss_data.get("baseScore", "N/A"))
            vector = cvss_data.get("vectorString", "N/A")
            severity = self._get_severity(score)
            
            table_data.append([
                cve_id,
                f"{score} ({severity})",
                vector,
                description[:100] + "..." if len(description) > 100 else description
            ])

        print("\n=== Vulnerabilities Found ===")
        print(tabulate(table_data, 
                     headers=["CVE ID", "CVSS Score", "Vector", "Description"],
                     tablefmt="grid"))

    def _get_severity(self, score):
        """Convert score to severity level."""
        try:
            score = float(score)
            if score >= 9.0: return "CRITICAL"
            elif score >= 7.0: return "HIGH"
            elif score >= 4.0: return "MEDIUM"
            elif score > 0: return "LOW"
        except:
            return "UNKNOWN"

    def _save_report(self, ip, service_info, cves):
        """Save results to JSON file."""
        os.makedirs("reports", exist_ok=True)
        filename = f"reports/vuln_scan_{ip}_{service_info['port']}.json"
        
        report = {
            "scan_time": datetime.now().isoformat(),
            "target": ip,
            "port": service_info["port"],
            "service": service_info["service"],
            "version": service_info["version"],
            "vulnerabilities": [
                {
                    "cve_id": cve["cve"]["id"],
                    "description": next(
                        (d["value"] for d in cve["cve"].get("descriptions", [])
                        if d["lang"] == "en"), ""
                    ),
                    "cvss_score": next(
                        (m[0]["cvssData"]["baseScore"] 
                        for m in cve["cve"].get("metrics", {}).values()
                        if m), "N/A"
                    )
                } for cve in cves
            ]
        }
        
        with open(filename, "w") as f:
            json.dump(report, f, indent=4)
        print(f"\n📄 Report saved to {filename}")